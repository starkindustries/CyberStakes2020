# Binary Exploitation 101

### 50 points

### Solve

Exploiting bugs in programs can definitely be difficult. Not only do you need a certain amount of reverse engineering required to identify vulnerabilities, but you also need to weaponize that vulnerability somehow. To get new hackers started, we included our annotated [BinEx101.c](./BinEx101.c) along with the compiled [BinEx101](./BinEx101).  
If you don't know where to start, download the source code and open it in a program with syntax highlighting such as `notepad++` or `gedit`. If you don't have the ability to use either of those, you can always use `vim`.  

You can connect to the problem at `telnet challenge.acictf.com 24680` or `nc challenge.acictf.com 24680`

### Hints

* Signed integers on modern computers generally use something called ["Two's Complement"](https://en.wikipedia.org/wiki/Two%27s_complement) for representing them. If this is your first time dealing with integers at this level, it is probably worth taking some time to get a basic understanding of them. In particular, you will need to understand what the largest positive number looks like, what -1 looks like, and how [overflow](https://en.wikipedia.org/wiki/Integer_overflow) is generally "handled".
* We've also included debug symbols in the binary and disabled compiler optimizations. Once you understand how the C code works from the source code, it is probably worth opening the compiled binary in something like [Ghidra](https://ghidra-sre.org/) to see both what the assembly looks like and how the recovered C code compares to the source code. Most of the other binary exploitation problems do not give you access to the raw source code.
* While many binary exploitation situations involve "non-standard" inputs (such as feeding shellcode as input to the name of something), this challenge does not. Once you understand the vulnerability, you can trigger it through normal interaction with the challenge. If you are having trouble on the math side, treating the binary representation of your 'target' number as an unsigned integer may be helpful.
* If you are new to binary exploitation (or C code), we really recommend reading the source file in its entirety as the comments try to explain many of the key concepts for this category of problems. For this specific problem, anyone not familiar C should definitely read the source file because the behavior of `s.numbers[-1]` is *very* different between C and some other popular languages (e.g. Python).

### Solution

The source code reveals that the flag is stored in `s.numbers[-1]`. The vulnerable code lies in this line:

`printf("%d * %d = %d which ends in a '%s'\r\n", first, second, tmp, s.numbers[tmp % 10]);`

In `s.numbers[tmp % 10]`, the value of `tmp` is just the product of the two numbers entered when running the binary.

The goal is to make `tmp` equal to `-1` so that `s.numbers[-1]` can print the flag. But how can two positive numbers multiply to get -1? This is where the two's complement hint comes in. With two's complement, any positive number can be converted to its negative complement by flipping all of its bits and then adding 1. See [BenEater's video](https://www.youtube.com/watch?v=4qH4unVtJkE) for a great explanation. 

With this in mind, -1 is equal to 11111111111111111111111111111111 (that's 32 1s) in binary. An unsigned 32bit integer with all 1s is equal to [4,294,967,295](https://en.wikipedia.org/wiki/4,294,967,295). Divide this by 5 to get: 858993459. Therefore 5 and 858993459 are the two numbers needed. Plug these into the program and get the flag.

`$ nc challenge.acictf.com 19919`